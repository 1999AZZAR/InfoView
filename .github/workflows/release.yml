name: Build and Release

on:
  push:
    tags:
      - 'v*'
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag name (e.g., v1.0.0)'
        required: false
        type: string

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Install Arduino CLI
      run: |
        curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | sh
        sudo mv bin/arduino-cli /usr/local/bin/
        arduino-cli version
        arduino-cli config init --overwrite
        
    - name: Install ESP32 board support
      run: |
        arduino-cli core update-index --additional-urls https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json
        # Install latest ESP32 platform version
        arduino-cli core install esp32:esp32
        # List installed versions for verification
        arduino-cli core list
        
    - name: Install required libraries
      run: |
        arduino-cli lib install "ChronosESP32"
        arduino-cli lib install "ESP32Time"
        arduino-cli lib install "Adafruit GFX Library"
        arduino-cli lib install "Adafruit SSD1306"
        
    - name: Compile firmware
      working-directory: ./code
      run: |
        echo "Starting compilation..."
        echo "Current directory: $(pwd)"
        echo "Arduino CLI config:"
        arduino-cli config dump || true
        echo ""
        echo "Checking for existing build directories:"
        find . -type d -name "build" 2>/dev/null || echo "No build directories found"
        echo ""
        echo "Compiling with explicit build path..."
        # Compile with explicit build directory in current location
        arduino-cli compile --fqbn esp32:esp32:esp32c3:PartitionScheme=default --build-path ./build --verbose code.ino
        COMPILE_EXIT=$?
        echo ""
        echo "Compilation exit code: $COMPILE_EXIT"
        if [ $COMPILE_EXIT -ne 0 ]; then
          echo "ERROR: Compilation failed with exit code $COMPILE_EXIT"
          exit 1
        fi
        echo ""
        echo "Build completed. Checking build directory structure..."
        if [ -d "build" ]; then
          echo "Build directory exists at: $(pwd)/build"
          echo "Contents:"
          ls -la build/ || true
          echo ""
          echo "Searching for .bin files:"
          find build -type f -name "*.bin" 2>/dev/null || echo "No .bin files found"
          echo ""
          echo "All files in build directory:"
          find build -type f 2>/dev/null || echo "No files found"
        else
          echo "WARNING: Build directory does not exist at ./build"
          echo "Searching for build directories elsewhere:"
          find . -type d -name "build" 2>/dev/null || echo "No build directories found"
          echo "Searching for any .bin files:"
          find . -type f -name "*.bin" 2>/dev/null || echo "No .bin files found"
        fi
        
    - name: Find and copy compiled binary
      working-directory: ./code
      run: |
        mkdir -p compiled
        echo "Searching for compiled binary..."
        echo "Current directory: $(pwd)"
        echo ""
        echo "Searching for build directories:"
        find . -type d -name "build" 2>/dev/null || echo "No build directories found"
        echo ""
        echo "Searching for all .bin files:"
        find . -type f -name "*.bin" 2>/dev/null || echo "No .bin files found"
        echo ""
        
        # Arduino CLI typically creates: build/esp32.esp32.esp32c3/code.ino.bin
        # But the exact path may vary, so we search comprehensively
        
        # First, try the most common location
        COMMON_PATHS=(
          "build/esp32.esp32.esp32c3/code.ino.bin"
          "build/esp32.esp32.esp32c3/code.bin"
          "build/code.ino.bin"
          "build/code.bin"
        )
        
        BINARY_FILE=""
        for TEST_PATH in "${COMMON_PATHS[@]}"; do
          if [ -f "$TEST_PATH" ]; then
            BINARY_FILE="$TEST_PATH"
            echo "Found binary at common path: $TEST_PATH"
            break
          fi
        done
        
        # If not found, search all build directories manually
        if [ -z "$BINARY_FILE" ] && [ -d "build" ]; then
          echo "Searching all build directories..."
          # Use a simple loop to find .bin files, excluding bootloader and partitions
          for BIN_FILE in $(find build -name "*.bin" -type f 2>/dev/null); do
            # Check if filename contains bootloader or partitions using shell pattern matching
            FILENAME=$(basename "$BIN_FILE")
            case "$FILENAME" in
              *[Bb]ootloader*|*[Pp]artitions*)
                continue
                ;;
              *)
                BINARY_FILE="$BIN_FILE"
                echo "Found binary: $BINARY_FILE"
                break
                ;;
            esac
          done
        fi
        
        # If still not found, try finding the largest .bin file (likely the main firmware)
        if [ -z "$BINARY_FILE" ] && [ -d "build" ]; then
          echo "Trying fallback: finding largest .bin file in build directory..."
          LARGEST_SIZE=0
          for BIN_FILE in $(find build -name "*.bin" -type f 2>/dev/null); do
            SIZE=$(stat -f%z "$BIN_FILE" 2>/dev/null || stat -c%s "$BIN_FILE" 2>/dev/null || echo "0")
            if [ "$SIZE" -gt "$LARGEST_SIZE" ]; then
              LARGEST_SIZE="$SIZE"
              BINARY_FILE="$BIN_FILE"
            fi
          done
          if [ -n "$BINARY_FILE" ]; then
            echo "Found largest binary: $BINARY_FILE (size: $LARGEST_SIZE bytes)"
          fi
        fi
        
        # Final check and copy
        if [ -n "$BINARY_FILE" ] && [ -f "$BINARY_FILE" ]; then
          cp "$BINARY_FILE" compiled/firmware.bin
          echo "Binary copied: $BINARY_FILE -> compiled/firmware.bin"
          ls -lh compiled/firmware.bin
          file compiled/firmware.bin
          echo "Binary size: $(du -h compiled/firmware.bin | cut -f1)"
        else
          echo "Error: Binary file not found"
          echo "Full directory tree:"
          find . -type f -name "*.bin" 2>/dev/null || echo "No .bin files found anywhere"
          echo ""
          echo "Build directory contents:"
          if [ -d "build" ]; then
            find build -type f 2>/dev/null || echo "No files in build directory"
          else
            echo "No build directory found"
          fi
          echo ""
          echo "Checking if compilation actually succeeded..."
          if [ ! -d "build" ]; then
            echo "ERROR: Build directory does not exist. Compilation may have failed."
          fi
          exit 1
        fi
        
    - name: Create source archive
      run: |
        git archive --format=zip --output=InfoView-source.zip HEAD
        
    - name: Determine release tag
      id: release_tag
      run: |
        echo "Event type: ${{ github.event_name }}"
        echo "Ref type: ${{ github.ref_type }}"
        echo "Ref name: ${{ github.ref_name }}"
        echo ""
        
        if [ "${{ github.ref_type }}" == "tag" ]; then
          # Use the tag that triggered the workflow
          TAG_NAME="${{ github.ref_name }}"
          echo "Using triggered tag: $TAG_NAME"
          CREATE_TAG=false
        elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          if [ -n "${{ github.event.inputs.tag }}" ]; then
            TAG_NAME="${{ github.event.inputs.tag }}"
            echo "Using manual input tag: $TAG_NAME"
            CREATE_TAG=true
          else
            # Get latest tag or create new one
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -z "$LATEST_TAG" ]; then
              TAG_NAME="v1.0.0"
              echo "No existing tags, using default: $TAG_NAME"
            else
              # Increment patch version
              VERSION=$(echo "$LATEST_TAG" | sed 's/v//')
              MAJOR=$(echo "$VERSION" | cut -d. -f1)
              MINOR=$(echo "$VERSION" | cut -d. -f2)
              PATCH=$(echo "$VERSION" | cut -d. -f3)
              PATCH=$((PATCH + 1))
              TAG_NAME="v${MAJOR}.${MINOR}.${PATCH}"
              echo "Incrementing from $LATEST_TAG to: $TAG_NAME"
            fi
            CREATE_TAG=true
          fi
        else
          # For branch pushes, use latest tag (don't create new ones to avoid loops)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LATEST_TAG" ]; then
            echo "No existing tags found. Skipping release creation for branch push."
            echo "To create a release, push a tag (e.g., git tag v1.0.0 && git push origin v1.0.0)"
            echo "skip_release=true" >> $GITHUB_OUTPUT
            exit 0
          else
            TAG_NAME="$LATEST_TAG"
            echo "Using latest tag for branch push: $TAG_NAME"
            CREATE_TAG=false
          fi
        fi
        
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "create_tag=$CREATE_TAG" >> $GITHUB_OUTPUT
        echo "skip_release=false" >> $GITHUB_OUTPUT
        
    - name: Create tag if needed
      if: steps.release_tag.outputs.create_tag == 'true'
      run: |
        TAG_NAME="${{ steps.release_tag.outputs.tag_name }}"
        echo "Creating tag: $TAG_NAME"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a "$TAG_NAME" -m "Release $TAG_NAME" || echo "Tag may already exist"
        git push origin "$TAG_NAME" || echo "Tag push failed or tag already exists"
        
    - name: Verify files exist
      run: |
        echo "Verifying release files exist..."
        if [ ! -f "InfoView-source.zip" ]; then
          echo "ERROR: InfoView-source.zip not found"
          exit 1
        fi
        if [ ! -f "code/compiled/firmware.bin" ]; then
          echo "ERROR: code/compiled/firmware.bin not found"
          exit 1
        fi
        echo "All release files verified"
        ls -lh InfoView-source.zip code/compiled/firmware.bin
        
    - name: Create release
      if: steps.release_tag.outputs.skip_release != 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.release_tag.outputs.tag_name }}
        name: InfoView ${{ steps.release_tag.outputs.tag_name }}
        files: |
          InfoView-source.zip
          code/compiled/firmware.bin
        generate_release_notes: false
        body: |
          ## InfoView ${{ steps.release_tag.outputs.tag_name }}
          
          Compiled firmware release for InfoView ESP32-C3 Smart Display.
          
          ### Release Contents
          
          - **firmware.bin**: Pre-compiled binary for ESP32-C3 device
          - **InfoView-source.zip**: Complete source code archive
          
          ### Installation Instructions
          
          **Method 1: Using Arduino CLI**
          
          ```bash
          arduino-cli upload -p /dev/ttyACM0 --fqbn esp32:esp32:esp32c3:PartitionScheme=default code.ino
          ```
          
          **Method 2: Using esptool (direct binary flash)**
          
          ```bash
          esptool.py --chip esp32c3 --port /dev/ttyACM0 write_flash 0x10000 firmware.bin
          ```
          
          ### Hardware Configuration
          
          - ESP32-C3 Super Mini development board
          - 0.96" OLED display module (SSD1306, I2C interface)
          - Pin connections: SDA=GPIO 9, SCL=GPIO 8
          
          ### Software Requirements
          
          - Chronos mobile application (Android)
          - Bluetooth Low Energy support
          
          ### Documentation
          
          Complete installation and usage instructions are available in README.md.
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

