name: Build and Release

on:
  push:
    tags:
      - 'v*'
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag name (e.g., v1.0.0)'
        required: false
        type: string

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Install Arduino CLI
      run: |
        curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | sh
        sudo mv bin/arduino-cli /usr/local/bin/
        arduino-cli version
        arduino-cli config init --overwrite
        
    - name: Install ESP32 board support
      run: |
        arduino-cli core update-index --additional-urls https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json
        # Install latest ESP32 platform version
        arduino-cli core install esp32:esp32
        # List installed versions for verification
        arduino-cli core list
        
    - name: Install required libraries
      run: |
        arduino-cli lib install "ChronosESP32"
        arduino-cli lib install "ESP32Time"
        arduino-cli lib install "Adafruit GFX Library"
        arduino-cli lib install "Adafruit SSD1306"
        
    - name: Compile firmware
      working-directory: ./code
      run: |
        echo "Starting compilation..."
        set -e  # Exit on error
        arduino-cli compile --fqbn esp32:esp32:esp32c3:PartitionScheme=default --verbose code.ino || {
          echo "Compilation failed!"
          exit 1
        }
        echo "Build completed successfully. Checking build directory structure..."
        if [ -d "build" ]; then
          echo "Build directory exists"
          ls -la build/ || true
          echo ""
          echo "Searching for .bin files:"
          find build -type f -name "*.bin" 2>/dev/null || echo "No .bin files found"
          echo ""
          echo "Build directory tree:"
          find build -type d 2>/dev/null | head -10 || true
        else
          echo "WARNING: Build directory does not exist!"
        fi
        
    - name: Find and copy compiled binary
      working-directory: ./code
      run: |
        mkdir -p compiled
        echo "Searching for compiled binary..."
        echo "Current directory: $(pwd)"
        echo "Build directory structure:"
        if [ -d "build" ]; then
          find build -type d 2>/dev/null || echo "No build directory"
        else
          echo "No build directory found"
        fi
        echo ""
        
        # Arduino CLI typically creates: build/esp32.esp32.esp32c3/code.ino.bin
        # But the exact path may vary, so we search comprehensively
        
        # First, try the most common location
        COMMON_PATHS=(
          "build/esp32.esp32.esp32c3/code.ino.bin"
          "build/esp32.esp32.esp32c3/code.bin"
          "build/code.ino.bin"
          "build/code.bin"
        )
        
        BINARY_FILE=""
        for TEST_PATH in "${COMMON_PATHS[@]}"; do
          if [ -f "$TEST_PATH" ]; then
            BINARY_FILE="$TEST_PATH"
            echo "Found binary at common path: $TEST_PATH"
            break
          fi
        done
        
        # If not found, search all build directories manually
        if [ -z "$BINARY_FILE" ] && [ -d "build" ]; then
          echo "Searching all build directories..."
          # Use a simple loop to find .bin files, excluding bootloader and partitions
          for BIN_FILE in $(find build -name "*.bin" -type f 2>/dev/null); do
            # Check if filename contains bootloader or partitions using shell pattern matching
            FILENAME=$(basename "$BIN_FILE")
            case "$FILENAME" in
              *[Bb]ootloader*|*[Pp]artitions*)
                continue
                ;;
              *)
                BINARY_FILE="$BIN_FILE"
                echo "Found binary: $BINARY_FILE"
                break
                ;;
            esac
          done
        fi
        
        # If still not found, try finding the largest .bin file (likely the main firmware)
        if [ -z "$BINARY_FILE" ] && [ -d "build" ]; then
          echo "Trying fallback: finding largest .bin file in build directory..."
          LARGEST_SIZE=0
          for BIN_FILE in $(find build -name "*.bin" -type f 2>/dev/null); do
            SIZE=$(stat -f%z "$BIN_FILE" 2>/dev/null || stat -c%s "$BIN_FILE" 2>/dev/null || echo "0")
            if [ "$SIZE" -gt "$LARGEST_SIZE" ]; then
              LARGEST_SIZE="$SIZE"
              BINARY_FILE="$BIN_FILE"
            fi
          done
          if [ -n "$BINARY_FILE" ]; then
            echo "Found largest binary: $BINARY_FILE (size: $LARGEST_SIZE bytes)"
          fi
        fi
        
        # Final check and copy
        if [ -n "$BINARY_FILE" ] && [ -f "$BINARY_FILE" ]; then
          cp "$BINARY_FILE" compiled/firmware.bin
          echo "Binary copied: $BINARY_FILE -> compiled/firmware.bin"
          ls -lh compiled/firmware.bin
          file compiled/firmware.bin
          echo "Binary size: $(du -h compiled/firmware.bin | cut -f1)"
        else
          echo "Error: Binary file not found"
          echo "Full directory tree:"
          find . -type f -name "*.bin" 2>/dev/null || echo "No .bin files found anywhere"
          echo ""
          echo "Build directory contents:"
          if [ -d "build" ]; then
            find build -type f 2>/dev/null || echo "No files in build directory"
          else
            echo "No build directory found"
          fi
          echo ""
          echo "Checking if compilation actually succeeded..."
          if [ ! -d "build" ]; then
            echo "ERROR: Build directory does not exist. Compilation may have failed."
          fi
          exit 1
        fi
        
    - name: Create source archive
      run: |
        git archive --format=zip --output=InfoView-source.zip HEAD
        
    - name: Determine release tag
      id: release_tag
      run: |
        if [ "${{ github.ref_type }}" == "tag" ]; then
          # Use the tag that triggered the workflow
          TAG_NAME="${{ github.ref_name }}"
          echo "Using triggered tag: $TAG_NAME"
        elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          if [ -n "${{ github.event.inputs.tag }}" ]; then
            TAG_NAME="${{ github.event.inputs.tag }}"
            echo "Using manual input tag: $TAG_NAME"
          else
            # Get latest tag
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -z "$LATEST_TAG" ]; then
              TAG_NAME="v1.0.0"
              echo "No existing tags, using default: $TAG_NAME"
            else
              TAG_NAME="$LATEST_TAG"
              echo "Using latest tag: $TAG_NAME"
            fi
          fi
        else
          # For branch pushes, get latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LATEST_TAG" ]; then
            echo "No existing tags found. Skipping release creation."
            echo "skip_release=true" >> $GITHUB_OUTPUT
            exit 0
          else
            TAG_NAME="$LATEST_TAG"
            echo "Using latest tag for branch push: $TAG_NAME"
          fi
        fi
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "skip_release=false" >> $GITHUB_OUTPUT
        
    - name: Create release
      if: steps.release_tag.outputs.skip_release != 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.release_tag.outputs.tag_name }}
        name: InfoView ${{ steps.release_tag.outputs.tag_name }}
        files: |
          InfoView-source.zip
          code/compiled/firmware.bin
        body: |
          ## InfoView ${{ steps.release_tag.outputs.tag_name }}
          
          Compiled firmware release for InfoView ESP32-C3 Smart Display.
          
          ### Release Contents
          
          - **firmware.bin**: Pre-compiled binary for ESP32-C3 device
          - **InfoView-source.zip**: Complete source code archive
          
          ### Installation Instructions
          
          **Method 1: Using Arduino CLI**
          
          ```bash
          arduino-cli upload -p /dev/ttyACM0 --fqbn esp32:esp32:esp32c3:PartitionScheme=default code.ino
          ```
          
          **Method 2: Using esptool (direct binary flash)**
          
          ```bash
          esptool.py --chip esp32c3 --port /dev/ttyACM0 write_flash 0x10000 firmware.bin
          ```
          
          ### Hardware Configuration
          
          - ESP32-C3 Super Mini development board
          - 0.96" OLED display module (SSD1306, I2C interface)
          - Pin connections: SDA=GPIO 9, SCL=GPIO 8
          
          ### Software Requirements
          
          - Chronos mobile application (Android)
          - Bluetooth Low Energy support
          
          ### Documentation
          
          Complete installation and usage instructions are available in README.md.
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

